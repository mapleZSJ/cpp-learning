
# 四、容器

1、线性容器   <br>
std::array：   <br>
与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 std::array 容器。   <br>
另外由于 std::vector 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存。   <br>
而和传统数组相对比，std::array 封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。   <br>
```
constexpr int len = 4;
std::array<int, len> arr1 = {1, 2, 3, 4};  // 数组大小参数必须是常量表达式
std::array<int, 4> arr2 = {1, 2, 3, 4};


兼容 C 风格的接口：
void foo(int *p, int len) {
    return;
}
std::array<int, 4> arr = {1,2,3,4};
// foo(arr, arr.size()); // 非法, 不同于 C 风格数组，std::array 无法隐式转换成 T* （int *arr_p = arr; //非法）
foo(&arr[0], arr.size());
foo(arr.data(), arr.size());
```

std::forward_list：   <br>
std::forward_list 是一个列表容器，使用方法和 std::list 基本类似。   <br>
需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），   <br>
也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。   <br>


2、无序容器   <br>
我们已经熟知了传统 C++ 中的有序容器 std::map/std::set，这些元素内部通过红黑树进行实现，插入和搜索的平均复杂度均为 O(log(size))。   <br>
在插入元素时候，会根据 < 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 < 操作符的顺序来逐个遍历。   <br>

而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)， 在不关心容器内部元素顺序时，能够获得显著的性能提升。   <br>

C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。   <br>

它们的用法和原有的 std::map/std::multimap/std::set/set::multiset 基本类似。   <br>

3、元组   <br>
关于元组的使用有三个核心的函数：   <br>
std::make_tuple  //构造元组   <br>
std::get  //获得元组某个位置的值   <br>
std::tie  //元组拆包   <br>
```
#include <tuple>
auto get_student(int id)
{
    // 返回类型被推断为 std::tuple<double, char, std::string>
    if (id == 0)
        return std::make_tuple(3.8, 'A', "张三");
    if (id == 1)
        return std::make_tuple(2.9, 'C', "李四");
    if (id == 2)
        return std::make_tuple(1.7, 'D', "王五");

    return std::make_tuple(0.0, 'D', "null"); // 如果只写 0 会出现推断错误, 编译失败
}
int main()
{
    auto student = get_student(0);
    std::cout << "ID: 0, "
    << "GPA: " << std::get<0>(student) << ", "
    << "成绩: " << std::get<1>(student) << ", "
    << "姓名: " << std::get<2>(student) << '\n';

    double gpa;
    char grade;
    std::string name;
    // 元组进行拆包
    std::tie(gpa, grade, name) = get_student(1);
    std::cout << "ID: 1, "
    << "GPA: " << gpa << ", "
    << "成绩: " << grade << ", "
    << "姓名: " << name << '\n';
}
```

std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：   <br>
```
std::tuple<std::string, double, double, int> t("123", 4.5, 6.7, 8);
std::cout << std::get<std::string>(t) << std::endl;
std::cout << std::get<double>(t) << std::endl; // 非法, 引发编译期错误
std::cout << std::get<3>(t) << std::endl;
```

运行期索引：   <br>
类模板 std::variant 表示一个类型安全的 联合体，可以存储几种不同类型中的一个值。   <br>
与 union 一样，如果 std::variant 持有一个某种对象类型 T 的值，则 T 对象会嵌套在 variant 对象内。   <br>
std::variant 不允许持有引用、数组或 void 类型，允许多次持有相同的类型，以及持有相同类型的不同 cv 限定版本(const 和 volatile 类型限定符) 。   <br>

与联合体在聚合初始化期间的行为一致，默认构造的 std::variant 持有其第一个可选类型的值，除非该可选类型不可默认构造（在这种情况下，std::variant也不可默认构造）。   <br>
std::monostate 可以用来表示 "无值" 状态，用无模板参数实例化 std::variant 定义的程序是错误的，可以改用 std::variant<std::monostate>。   <br>
```
#include <variant>
#include <string>
int main() {
    std::variant<int, float, std::string> v;
    v = 42; // v 现在包含 int
    std::cout << std::get<int>(v) << std::endl; // 输出：42
    
    v = 3.14f; // v 现在包含 float
    std::cout << std::get<float>(v) << std::endl; // 输出：3.14
    
    v = "hello"; // v 现在包含 string
    std::cout << std::get<std::string>(v) << std::endl; // 输出：hello
    
    // 使用 std::get_if 安全地获取值
    if (const auto intPtr = std::get_if<int>(&v)) {
        std::cout << "It's an int: " << *intPtr << std::endl;
    } else {
        std::cout << "It's not an int" << std::endl;
    }
}
```
```
int index = 1;
std::get<index>(t);  //不合法，std::get<> 依赖一个编译期的常量

而使用 std::variant<>（C++ 17 引入），提供给 variant<> 的类型模板参数可以让一个 variant<> 从而容纳提供的几种类型的变量：
#include <variant>
template <size_t n, typename... T>
constexpr std::variant<T...> _tuple_index(const std::tuple<T...>& tpl, size_t i) {
    if constexpr (n >= sizeof...(T))
        throw std::out_of_range("越界.");
    if (i == n)
        return std::variant<T...>{ std::in_place_index<n>, std::get<n>(tpl) };
    return _tuple_index<(n < sizeof...(T)-1 ? n+1 : 0)>(tpl, i);
}
template <typename... T>
constexpr std::variant<T...> tuple_index(const std::tuple<T...>& tpl, size_t i) {
    return _tuple_index<0>(tpl, i);
}
template <typename T0, typename ... Ts>
std::ostream & operator<< (std::ostream & s, std::variant<T0, Ts...> const & v) { 
    std::visit([&](auto && x){ s << x; }, v);
    return s;
}

这样我们就能：
int i = 1;
std::cout << tuple_index(t, i) << std::endl;

std::visit 允许我们以一种类型安全的方式访问 std::variant 中的值：
#include <variant>
struct Visitor {
    void operator()(int i) { std::cout << "It's an int: " << i << std::endl; }
    void operator()(float f) { std::cout << "It's a float: " << f << std::endl; }
    void operator()(const std::string& s) { std::cout << "It's a string: " << s << std::endl; }
};
 
int main() {
    std::variant<int, float, std::string> v = 42;
    std::visit(Visitor{}, v); // 输出：It's an int: 42
    
    v = 3.14f;
    std::visit(Visitor{}, v); // 输出：It's a float: 3.14
    
    v = "hello";
    std::visit(Visitor{}, v); // 输出：It's a string: hello
}
```

元组合并与遍历：   <br>
还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：   <br>
auto new_tuple = std::tuple_cat(get_student(1), std::move(t));   <br>
```
快速遍历一个元组：
template <typename T>
auto tuple_len(T &tpl) {
    return std::tuple_size<T>::value;
}
for(int i = 0; i != tuple_len(new_tuple); ++i)
    // 运行期索引
    std::cout << tuple_index(i, new_tuple, i) << std::endl;
```



# 五、智能指针与内存管理

1、RAII 与引用计数   <br>
引用计数这种计数是为了防止内存泄露而产生的。基本想法是对于动态分配的对象，进行引用计数，   <br>
每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。   <br>

对于一个对象而言，在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，就是 RAII 资源获取即初始化技术。   <br>
C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。    <br>
这些智能指针就包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 <memory>。   <br>

注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。   <br>

2、std::shared_ptr   <br>
std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete，当引用计数变为零的时候就会将对象自动删除。   <br>
但因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。   <br>
std::make_shared 就能够用来消除显式的使用 new，所以std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。例如：   <br>
```
#include <memory>
void foo(std::shared_ptr<int> i)
{
    (*i)++;
}
int main()
{
    // auto pointer = new int(10); // illegal, no direct assignment
    auto pointer = std::make_shared<int>(10); // Constructed a std::shared_ptr
    foo(pointer);
    std::cout << *pointer << std::endl; // The shared_ptr will be destructed before leaving the scope
    return 0;
}

std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。例如：
auto pointer = std::make_shared<int>(10);
auto pointer2 = pointer; // 引用计数+1
auto pointer3 = pointer; // 引用计数+1
int *p = pointer.get(); // 这样不会增加引用计数
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 3
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 3
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 3
pointer2.reset();
std::cout << "reset pointer2:" << std::endl;
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 2
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 0, pointer2 已 reset
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 2
pointer3.reset();
std::cout << "reset pointer3:" << std::endl;
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 1
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 0
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 0, pointer3 已 reset
```

3、std::unique_ptr   <br>
std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：   <br>
```
std::unique_ptr<int> pointer = std::make_unique<int>(10); // make_unique 从 C++14 引入
std::unique_ptr<int> pointer2 = pointer; // 非法

// C++11 没有提供 std::make_unique，可以自行实现：
template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args ) {
  return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}
```

unique_ptr 不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如：   <br>
```
#include <memory>
struct Foo {
    Foo() { std::cout << "Foo::Foo" << std::endl; }
    ~Foo() { std::cout << "Foo::~Foo" << std::endl; }
    void foo() { std::cout << "Foo::foo" << std::endl; }
};
void f(const Foo &) {
    std::cout << "f(const Foo&)" << std::endl;
}
int main() {
    std::unique_ptr<Foo> p1(std::make_unique<Foo>());
    if (p1) p1->foo(); // p1 不空, 输出
    {
        std::unique_ptr<Foo> p2(std::move(p1));
        f(*p2); // p2 不空, 输出
        if(p2) p2->foo(); // p2 不空, 输出
        if(p1) p1->foo(); // p1 为空, 无输出
        p1 = std::move(p2);
        if(p2) p2->foo(); // p2 为空, 无输出
        std::cout << "p2 被销毁" << std::endl;
    }
    if (p1) p1->foo(); // p1 不空, 输出
}
```

4、std::weak_ptr   <br>
std::shared_ptr 依然存在着资源无法释放的问题：
```
struct A;
struct B;
struct A {
    std::shared_ptr<B> pointer;
    ~A() {
        std::cout << "A 被销毁" << std::end;
    }
};
struct B {
    std::shared_ptr<A> pointer;
    ~B() {
        std::cout << "B 被销毁" << std::end;
    }
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a.pointer = b;
    b.pointer = a;
}
```
运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引用计数均变为了 2。而离开作用域时，a,b 智能指针被析构，内存区域的引用计数减一。   <br>
a,b 对象指向的内存区域引用计数不为零（因为 a,b 内部的 pointer 强引用无法释放），而外部已经没有办法找到这块区域了，也就造成了内存泄露。   <br>

解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用），用于配合 std::shared_ptr 管理对象生命周期。
它不增加引用计数，被释放时，之前所指堆内存的引用计数也不会因此而减 1。它主要用于避免循环引用和安全访问共享对象。当其中一方换用弱引用时候，就可以打破循环引用：   <br>
```
#include <memory>
struct B;
struct A {
   shared_ptr<B> ptrB;
   ~A() { cout << "~A()\n"; }
};
struct B {
   weak_ptr<A> ptrA; // 弱引用，避免循环
   ~B() { cout << "~B()\n"; }
};
int main() {
   auto a = make_shared<A>();
   auto b = make_shared<B>();
   a->ptrB = b;
   b->ptrA = a; // 不增加引用计数
   cout << "use_count of a: " << a.use_count() << endl;
}
```
std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在。   <br>
其 expired() 方法能在资源未被释放时，会返回 true，否则返回 false。   <br>