
# 一、c++11 弃用

char *str = "hello world!"; //弃用   <br>
如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。

C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。

auto_ptr 被弃用，应使用 unique_ptr。

register 关键字被弃用，可以使用但不再具备任何实际含义。

bool 类型的 ++ 操作被弃用。

如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。

C 语言风格的类型转换被弃用（即在变量前使用 (convert_type)），应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。

特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <ccomplex>、<cstdalign>、<cstdbool> 与 <ctgmath> 等

还有一些其他诸如参数绑定（C++11 提供了 std::bind 和 std::function）、export 等特性也均被弃用。

在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法。



# 二、语言可用性的强化
(重点学习：auto 类型推导、范围 for 迭代、初始化列表、变参模板)

1、nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。

C++ 不允许直接将 void * 隐式转换到其他类型。

但如果编译器尝试把 NULL 定义为 ((void*)0)，那么在这句代码中 char *ch = NULL; 没有了 void * 隐式转换的 C++ 只好将NULL 定义为 0。而这会将 NULL 定义成 0 将导致 C++ 中重载特性发生混乱。

为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。


2、constexpr
```
int len = 10;
const int len_2 = len + 1;  //len_2是 const 常数，而不是常量表达式
constexpr int len_2_constexpr = 1 + 2 + 3;
// char arr_4[len_2];                // 非法，因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 len_2 而言，这是一个 const 常数，而不是一个常量表达式
char arr_4[len_2_constexpr];         // 合法
```

constexpr 它将表达式或函数编译为常量结果，让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 某个变量 在编译期就应该是一个常量表达式。

C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件。例如：if constexpr (std::is_integral<T>::value) {...}


3、if/switch 变量声明强化:   <br>
```
//将临时变量 itr 放到 if 语句内:
if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) {
    *itr = 4;
}
```

4、std::initializer_list，C++11把初始化列表的概念绑定到了类型上，允许构造函数或其他函数像参数一样使用初始化列表
```
//初始化列表构造函数：
class MagicFoo {
public:
    std::vector<int> vec;
    MagicFoo(std::initializer_list<int> list) {
        for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it)
            vec.push_back(*it);
    }
};
```
ps：初始化列表除了用在对象构造上，还能将其作为普通函数的形参。


5、结构化绑定   <br>
结构化绑定提供了类似其他语言中提供的多返回值的功能。C++11 新增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。   <br>
但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们必须清楚元组包含多少个对象，各个对象是什么类型。   <br>

C++17 完善了这一设定，结构化绑定示例代码如下：   <br>
```
#include <tuple>
std::tuple<int, double, std::string> f() {
    return std::make_tuple(1, 2.3, "456");
}
int main() {
    auto [x, y, z] = f();
    std::cout << x << ", " << y << ", " << z << std::endl;
    return 0;
}
```

6、类型推导   <br>
auto 不能用于函数传参，比如int add(auto x, auto y)（考虑重载的问题，我们应该使用模板）；auto 还不能用于推导数组类型。   <br>

decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：decltype(表达式)。

std::is_same<T, U> 用于判断 T 和 U 这两个类型是否相等，例如：std::is_same<decltype(x), int>::value。

```
推导函数的返回类型时，在传统 C++ 中我们必须这么写：
template<typename R, typename T, typename U>
R add(T x, U y) {
    return x+y
}

C++11 引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：
template<typename T, typename U>
auto add2(T x, U y) -> decltype(x+y){
    return x + y;
}
auto w = add2<int, double>(1, 2.0);

从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：
template<typename T, typename U>
auto add3(T x, U y){
    return x + y;
}
auto q = add3<double, int>(1.0, 2);
```

decltype(auto) 是 C++14 开始提供的一个略微复杂的用法，主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。

```
当我们需要对此函数进行封装时：std::string  lookup1();
C++11 中，封装实现如下形式：
std::string look_up_a_string_1() {
    return lookup1();
}
而有了 decltype(auto)，我们可以让编译器完成参数转发：
decltype(auto) look_up_a_string_1() {
    return lookup1();
}
```

7、外部模板   <br>
传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。   <br>
为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：   <br>
template class std::vector<bool>;          // 强行实例化   <br>
extern template class std::vector<double>; // 不在该当前编译文件中实例化模板   <br>


8、类型别名模板   <br>
typedef 定义别名的语法是：typedef 原名称 新名称;   <br>
模板是用来产生类型的。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。   <br>
C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：   <br>
```
template<typename T, typename U>
class MagicType {
public:
    T dark;
    U magic;
};

typedef int (*process)(void *);  //对函数指针等别名的定义语法 和基础语法不相同
using NewProcess = int(*)(void *);
template<typename T>
using TrueDarkMagic = MagicType<std::vector<T>, std::string>;
int main() {
    TrueDarkMagic<bool> you;
}
```

9、默认模板参数   <br>
为了避免使用模板函数时，每次都必须指定其模板参数的类型， C++11 提供了一种便利，可以指定模板的默认参数：   <br>
```
template<typename T = int, typename U = int>
auto add(T x, U y) -> decltype(x+y) {
    return x+y;
}
```

10、变长参数模板   <br>
template<typename... Ts> class Magic;  // C++11 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。   <br>
例如：class Magic<int, std::vector<int>, std::map<std::string, std::vector<int>>> darkMagic;   <br>
既然是任意形式，所以个数为 0 的模板参数也是可以的：class Magic<> nothing;   <br>
如果不希望产生的模板参数个数为0，可以手动的定义至少一个模板参数：template<typename Require, typename... Args> class Magic;   <br>
使用 sizeof 来计算参数的个数：   <br>
```
template<typename... Ts>
void magic(Ts... args) {
    std::cout << sizeof...(args) << std::endl;
}
```
```
对参数解包：
(1)递归模板函数：
template<typename T0>
void printf1(T0 value) {
    std::cout << value << std::endl;
}
template<typename T, typename... Ts>
void printf1(T value, Ts... args) {
    std::cout << value << std::endl;
    printf1(args...);
}
(2)变参模板展开，C++17 增加了变参模板展开的支持
template<typename T0, typename... T>
void printf2(T0 t0, T... t) {
    std::cout << t0 << std::endl;
    if constexpr (sizeof...(t) > 0) printf2(t...);
}
事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 std::bind 及 完美转发 等特性实现对函数和参数的绑定，从而达到成功调用的目的。
(3)初始化列表展开
template<typename T, typename... Ts>
auto printf3(T value, Ts... args) {
    std::cout << value << std::endl;
    (void) std::initializer_list<T>{([&args] {
        std::cout << args << std::endl;
    }(), value)...};
}
这里额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性。通过初始化列表，(lambda 表达式, value)... 将会被展开。
由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list 显式的转为 void。
```

C++ 17 中将变长参数这种特性进一步带给了表达式，称为折叠表达式：
```
template<typename ... T>
auto sum(T ... t) {
    return (t + ...);
}
int main() {
    std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
}
```

前面主要提及的是模板参数的一种形式：类型模板参数（如：template <typename T, typename U>  auto func1(){...}），其中模板的参数 T 和 U 为具体的类型。   <br>
但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：（如：template <typename T, int BufSize>  auto func2(){...}），   <br>
从 c++17 起，可以使用 auto 推断非类型模板参数：template <auto value> void foo() {...}   <br>


11、构造函数   <br>
C++11 引入了 委托构造 的概念，使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而简化代码。   <br>
```
class Base {
public:
    int value1, value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() { // 委托 Base() 构造函数
        value2 = value;
    }
};
int main() {
    Base b(2);
    std::cout << b.value1 << b.value2 << std::endl;
}

在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的。C++11 利用关键字 using 引入了 继承构造函数 的概念：
class Subclass : public Base {
public:
    using Base::Base; // 继承构造
};
int main() {
    Subclass s(3);
    std::cout << s.value1 << s.value2 << std::endl;
}
```

12、显式虚函数重载   <br>
为了防止子类意外重载虚函数，C++11 引入了 override 和 final 这两个关键字。   <br>
override：当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：   <br>
```
struct Base {
    virtual void foo(int);
};
struct SubClass: Base {
    virtual void foo(int) override; // 合法
    virtual void foo(float) override; // 非法, 父类没有此虚函数
};

final：防止类被继续继承以及终止虚函数继续重载引入。
struct Base {
    virtual void foo() final;
};
struct SubClass1 final: Base {
}; // 合法
struct SubClass2 : SubClass1 {
}; // 非法, SubClass1 已 final
struct SubClass3: Base {
    void foo(); // 非法, foo 已 final
};

显式禁用默认函数。为了精确控制默认函数的生成行为，C++11 允许显式的声明采用或拒绝编译器自带的函数：
class Magic {
    public:
    Magic() = default; // 显式声明使用编译器生成的构造
    Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造
    Magic(int magic_number);
}
```


13、强类型枚举   <br>
在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较，甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同。   <br>
C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：   <br>
```
enum class new_enum : unsigned int {  // 枚举类型后面使用了冒号及类型关键字，来指定枚举中枚举值的类型，为枚举赋值（未指定时将默认使用 int）。
    value1,
    value2 = 100,
    value3 = 100
};
```
这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。   <br>
但相同枚举值之间如果指定的值相同，那么可以进行比较：if (new_enum::value3 == new_enum::value4) {...}   <br>
而想要获取枚举值的值时，必须显式的进行类型转换，不过我们可以通过重载 << 这个算符来进行输出：   <br>
```
template<typename T>
std::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
{
    return stream << static_cast<typename std::underlying_type<T>::type>(e);
}
int main() {
    std::cout << new_enum::value3 << std::endl;
    return 0;
}
```



# 三、语言运行期的强化

1、Lambda 表达式   <br>
Lambda 表达式的基本语法如下：   <br>
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {   <br>
// 函数体   <br>
}   <br>

捕获列表：可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下不可使用函数体外部的变量，这时捕获列表可以起到传递外部数据的作用。   <br>
根据传递的行为，捕获列表也分为以下几种：   <br>
(1)值捕获   <br>
与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝， 而非调用时才拷贝：   <br>
```
void lambda_value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout << "stored_value = " << stored_value << std::endl;  // stored_value == 1，而 value == 100，因为 copy_value 在创建时就保存了一份 value 的拷贝
}
```

(2)引用捕获   <br>
与引用传参类似，引用捕获保存的是引用，值会发生变化。   <br>
```
void lambda_reference_capture() {
    int value = 1;
    auto copy_value = [&value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout << "stored_value = " << stored_value << std::endl;  // stored_value == 100， value == 100，因为 copy_value 保存的是引用
}
```

(3)隐式捕获   <br>
手动书写捕获列表有时候是非常复杂的，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用引用捕获或者值捕获.   <br>
总结一下，捕获提供了lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：   <br>
[] 空捕获列表   <br>
[name1, name2, …] 捕获一系列变量   <br>
[&] 引用捕获, 让编译器自行推导捕获列表   <br>
[=] 值捕获, 让编译器自行推导引用列表   <br>

(4)表达式捕获   <br>
上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。   <br>
C++14 允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：   <br>
```
#include <utility>
int main() {
    auto important = std::make_unique<int>(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
        return x+y+v1+(*v2);
    };
    std::cout << add(3, 4) << std::endl;
    return 0;
}
在上面的代码中，important 是一个独占指针，是不能够被捕获到的，这时候我们需要将其转移为右值，在表达式中初始化。
```

泛型 Lambda：   <br>
auto 关键字不能用在参数表里，这是因为这样的写法会与模板的功能产生冲突。 但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。    <br>
为了解决 Lambda 参数表不能够泛化，必须明确参数表类型的问题，从 C++14 开始，Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型：   <br>
```
auto add = [](auto x, auto y) {
    return x+y;
};
add(1, 2);
add(1.1, 2.2);
```


2、函数对象包装器   <br>
std::function：   <br>
Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象），当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：   <br>
```
using foo = void(int); // 定义函数类型
void functional(foo f) { // 定义在参数列表中的函数类型 foo 被视为退化后的函数指针类型 foo*
    f(1); // 通过函数指针调用函数
}
int main() {
    auto f = [](int value) {
        std::cout << value << std::endl;
    };
    functional(f); // 传递闭包对象，隐式转换为 foo* 类型的函数指针值
    f(1); // lambda 表达式调用
    return 0;
}
```

在 C++11 中，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。   <br>
C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，    <br>
它也是对 C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），    <br>
换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如：   <br>
```
#include <functional>
int foo(int para) {
    return para;
}
int main() {
    std::function<int(int)> func = foo;  // std::function 包装了一个返回值为 int, 参数为 int 的函数
    int important = 10;
    std::function<int(int)> func2 = [&](int value) -> int {
        return 1+value+important;
    };
    std::cout << func(10) << func2(10) << std::endl;
}
```

3、std::bind 和 std::placeholder   <br>
std::bind 是C++11引入的功能模板，位于<functional>头文件中，用于将函数、成员函数或函数对象与特定参数绑定，生成一个新的可调用对象。   <br>
有时我们并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。   <br>
```
#include <functional>
void print_sum(int a, int b) {
    std::cout << a + b << std::endl;
}
int main() {
    auto bound_print = std::bind(print_sum, 10, std::placeholders::_1);  // std::placeholders 占位符，_1表示调用时传入的第1个参数
    bound_print(20);   //输出30，相当于print_sum(10, 20)
    return 0;
}

void f(int a) {};
int main() {
    int x = 10;
    auto bound1 = std::bind(f, x);  //按值捕获参数
    auto bound2 = std::bind(f, std::ref(x));  //引用捕获，使用std::ref或std::cref

    x = 20;
    bound1();  //使用x的副本(值为10)
    bound2();  //使用x的引用(值为20)
}
```

绑定成员函数时需要传入对象指针或引用：   <br>
```
class MyClass {
public:
    void print(int x) {
        std::cout << "value: " << x << std::endl;
    }
}

int main() {
    MyClass obj;
    auto bound_member = std::bind(&MyClass::print, &obj, std::placeholders::_1);  //bind(成员函数指针， 对象的指针， 成员函数的参数...)
    bound_member(42);
    return 0;
}
```

4、右值引用（&&）   <br>
左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据；   <br>
而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。   <br>
C++11 标准中对右值做了更细致的划分，分别称为纯右值（pure value，简称 pvalue）和将亡值（expiring value，简称 xvalue ），   <br>
其中纯右值就是 C++98/03 标准中的右值，可以被移动（move）但不能被拷贝（copy），非引用返回的临时变量、运算表达式产生的临时变量、原始字面量(例如：10、true)、Lambda 表达式都属于纯右值；   <br>
而将亡值是 C++11 为了引入右值引用而提出的概念，指的是和右值引用相关的表达式（比如某函数返回的 T && 类型的表达式）。对于纯右值和将亡值，都属于右值。   <br>
```
std::vector<int> foo() {
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;  //在 C++11 之后，此处的左值 temp 会被编译器进行隐式右值转换，等价于 static_cast<std::vector<int> &&>(temp)
}
std::vector<int> v = foo();
```

右值引用的声明：T &&，其中 T 是类型。右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。   <br>
C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象。   <br>
注意，std::move 会改变原来的左值，所以在使用它之后，原来的左值就不能再使用了。如果不小心再次使用了被std::move()处理过的左值，可能会导致数据丢失。   <br>

std::string a = "hello";   <br>
std::string b = std::move(a); // 这里发生移动构造   <br>
这时 a 的状态是 有效但未指定（valid but unspecified），a 仍然是一个“可以安全析构、可以重新赋值”的对象，但它里面的具体值是什么不保证。   <br>
对很多标准库类型（如 std::string, std::vector），常见实现里 a 往往会变成空，但不能依赖这一点写逻辑。   <br>

对于“被 move 过的对象”，通常还是允许析构、重新赋值（a = "x"; 或 a = std::string{...};）；   <br>
调用不依赖具体内容的成员（例如 a.clear()、a.swap(...) 等）；   <br>
读取它的值并基于其内容做判断（例如 if(a.empty()) ...），不建议依赖结果，因为“未指定”。   <br>

move 不等于“置空/置零/不可用”，std::move 之后的变量仍然是左值变量，仍然可以用名字 a 访问它；只是表达式 std::move(a) 是右值引用。   <br>

tips：   <br>
C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值(const int &b = std::move(1))。也就是说，常量左值引用既可以操作左值，也可以操作右值。   <br>
但和常量左值引用不同的是，右值引用还可以对右值进行修改。另外，C++ 语法上是支持定义常量右值引用的(const int&& a = 10)，但这种定义出来的右值引用并无实际用处。   <br>


5、完美转发   <br>
std::forward 是一个模板函数，用于在模板函数中转发参数，同时保持其值类别。其主要功能是在传递参数时，将参数的左值或右值语义正确地传递给目标函数。   <br>
```
template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept
{ 
    return static_cast<_Tp&&>(__t);
}

template<typename _Tp>
constexpr _Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
        " substituting _Tp is an lvalue reference type");
    return static_cast<_Tp&&>(__t);
}
```
std::remove_reference 的功能是消除类型中的引用， 而 std::is_lvalue_reference 用于检查类型是否为左值引用类型。   <br>

完美转发(Perfect Forwarding)：函数模板能够将函数参数的 值类别（左值、右值） 和 const、volatile 等修饰符完整保留并传递。   <br>
在函数模板中，常常需要将参数传递给另一个函数，完美转发的目标是确保传递的参数在语义上保持不变，这种能力由 std::forward 和右值引用(&&)共同实现。   <br>
完美转发基于引用折叠规则(引用坍缩规则)：T& & -> T&   T& && -> T&  T&& & -> T&  T&& && -> T&&   <br>
```
#include <utility>
void process(int& x) { std::cout << "lvalue: " << x << std::endl; }
void process(int&& x) { std::cout << "rvalue: " << x << std::endl; }

template<typename T>
void wrapper(T&& arg) {
    process(std::forward<T>(arg));  //完美转发
}

int main() {
    int x = 10;
    wrapper(x);     //左值，T推导为int&，std::forward<int&>(arg)返回左值引用，调用lvalue版本
    wrapper(20);    //右值，T推导为int，std::forward<int>(arg)返回右值引用，调用rvalue版本
    wrapper(std::move(x));  //右值，std::move(x)将x转为右值，T推导为int，std::forward<int>(arg)返回右值引用，调用rvalue版本
    return 0;
}
```
注意：只在模板函数中使用  转发后不要再用该参数、不要重复转发同一个参数   <br>
在设计函数模板时，需注意避免因重载导致编译器难以推断模板参数   <br>
T&& + forward<T> 就是完美转发的全部秘诀   <br>
在使用循环语句的过程中，auto&& 是最安全的方式，因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。   <br>
